// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: requirement.sql

package connector

import (
	"context"
	"database/sql"
)

const deleteFromRequirementByID = `-- name: DeleteFromRequirementByID :exec
update requirement
set deleted_at = now()
where id = $1
`

func (q *Queries) DeleteFromRequirementByID(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteFromRequirementByID, id)
	return err
}

const insertIntoRequirement = `-- name: InsertIntoRequirement :one
insert into requirement (id, code, title, description, user_story, type_id, origin_id, priority_id, project_id, created_at, updated_at, deleted_at)
values (default, $1, $2, $3, $4, $5, $6, $7, $8, now(), null, null)
returning id
`

type InsertIntoRequirementParams struct {
	Code        string
	Title       string
	Description sql.NullString
	UserStory   sql.NullString
	TypeID      int32
	OriginID    int32
	PriorityID  int32
	ProjectID   int32
}

func (q *Queries) InsertIntoRequirement(ctx context.Context, arg InsertIntoRequirementParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, insertIntoRequirement,
		arg.Code,
		arg.Title,
		arg.Description,
		arg.UserStory,
		arg.TypeID,
		arg.OriginID,
		arg.PriorityID,
		arg.ProjectID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const selectAllFromRequirement = `-- name: SelectAllFromRequirement :many

select id, code, title, description, user_story, type_id, origin_id, priority_id, project_id, created_at, updated_at, deleted_at from requirement
`

// requirement
func (q *Queries) SelectAllFromRequirement(ctx context.Context) ([]Requirement, error) {
	rows, err := q.db.QueryContext(ctx, selectAllFromRequirement)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Requirement
	for rows.Next() {
		var i Requirement
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Title,
			&i.Description,
			&i.UserStory,
			&i.TypeID,
			&i.OriginID,
			&i.PriorityID,
			&i.ProjectID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRequirementByID = `-- name: SelectRequirementByID :one
select id, code, title, description, user_story, type_id, origin_id, priority_id, project_id, created_at, updated_at, deleted_at from requirement where id = $1
`

func (q *Queries) SelectRequirementByID(ctx context.Context, id int32) (Requirement, error) {
	row := q.db.QueryRowContext(ctx, selectRequirementByID, id)
	var i Requirement
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Title,
		&i.Description,
		&i.UserStory,
		&i.TypeID,
		&i.OriginID,
		&i.PriorityID,
		&i.ProjectID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateRequirementByID = `-- name: UpdateRequirementByID :exec
update requirement
set
    code = $1,
    title = $2,
    description = $3,
    user_story = $4,
    type_id = $5,
    origin_id = $6,
    priority_id = $7,
    project_id = $8,
    updated_at = now()
where id = $9
`

type UpdateRequirementByIDParams struct {
	Code        string
	Title       string
	Description sql.NullString
	UserStory   sql.NullString
	TypeID      int32
	OriginID    int32
	PriorityID  int32
	ProjectID   int32
	ID          int32
}

func (q *Queries) UpdateRequirementByID(ctx context.Context, arg UpdateRequirementByIDParams) error {
	_, err := q.db.ExecContext(ctx, updateRequirementByID,
		arg.Code,
		arg.Title,
		arg.Description,
		arg.UserStory,
		arg.TypeID,
		arg.OriginID,
		arg.PriorityID,
		arg.ProjectID,
		arg.ID,
	)
	return err
}
